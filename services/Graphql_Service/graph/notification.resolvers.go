package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"database/sql"
	"fmt"
	"graphql/graph/model"
	"log"
	"strings"
	"time"

	_ "github.com/lib/pq"
)

// GetMyNotifications is the resolver for the getMyNotifications field.
func (r *queryResolver) GetMyNotifications(ctx context.Context, filter *string, limit *int32, offset *int32) ([]*model.Notification, error) {
	// 1. Get Current User ID
	currentUserID, err := getCurrentUserID(ctx) // From auth.go
	if err != nil {
		log.Printf("GetMyNotifications Error: Not authenticated: %v", err)
		return nil, fmt.Errorf("authentication required")
	}

	// 2. Database Connection
	db, err := getDB() // From helper.go
	if err != nil {
		log.Printf("GetMyNotifications DB Error: %v", err)
		return nil, fmt.Errorf("internal server error connecting to DB")
	}
	defer db.Close()

	// 3. Build SQL Query
	var queryBuilder strings.Builder
	args := []interface{}{}
	argCounter := 1

	queryBuilder.WriteString(`
		SELECT
			n.notification_id, n.recipient_user_id, n.notification_type, n.entity_id, n.is_read, n.created_at,
			n.triggering_user_id,
			a.email, a.first_name, a.last_name, a.address, a.phone, a.age, a.gender, a.created_at as account_created_at, a.updated_at as account_updated_at
		FROM notifications n
		LEFT JOIN accounts a ON n.triggering_user_id = a.id
		WHERE n.recipient_user_id = $`)
	queryBuilder.WriteString(fmt.Sprintf("%d", argCounter))
	args = append(args, currentUserID)
	argCounter++

	// Add filtering (Example: filter by 'unread')
	if filter != nil {
		if *filter == "unread" {
			queryBuilder.WriteString(fmt.Sprintf(" AND n.is_read = false"))
		}
		// Add more filters here if needed (e.g., by notification_type)
		// else if *filter == "type_like" {
		//  queryBuilder.WriteString(fmt.Sprintf(" AND n.notification_type = 'like'"))
		// }
	}

	queryBuilder.WriteString(" ORDER BY n.created_at DESC")

	// Add pagination
	if limit != nil {
		queryBuilder.WriteString(fmt.Sprintf(" LIMIT $%d", argCounter))
		args = append(args, *limit)
		argCounter++
	} else {
		// Default limit if not provided
		queryBuilder.WriteString(fmt.Sprintf(" LIMIT $%d", argCounter))
		args = append(args, 20) // Default to 20 notifications
		argCounter++
	}

	if offset != nil {
		queryBuilder.WriteString(fmt.Sprintf(" OFFSET $%d", argCounter))
		args = append(args, *offset)
		argCounter++
	} else {
		queryBuilder.WriteString(fmt.Sprintf(" OFFSET $%d", argCounter))
		args = append(args, 0) // Default to offset 0
		argCounter++
	}

	finalQuery := queryBuilder.String()
	log.Printf("Executing GetMyNotifications query: %s with args: %v", finalQuery, args)

	// 4. Execute Query
	queryCtx, cancelQuery := context.WithTimeout(ctx, 10*time.Second)
	defer cancelQuery()
	rows, err := db.QueryContext(queryCtx, finalQuery, args...)
	if err != nil {
		log.Printf("GetMyNotifications DB Error executing query: %v", err)
		return nil, fmt.Errorf("failed to fetch notifications")
	}
	defer rows.Close()

	// 5. Scan Results
	notifications := []*model.Notification{}
	for rows.Next() {
		var notif model.Notification
		var triggeringUserID sql.NullString // Use sql.NullString for nullable FK
		var entityID sql.NullString         // Use sql.NullString for nullable FK
		var createdAt time.Time

		// Nullable fields for the triggering account
		var accEmail sql.NullString
		var accFirstName sql.NullString
		var accLastName sql.NullString
		var accAddress sql.NullString
		var accPhone sql.NullString
		var accAge sql.NullInt32
		var accGender sql.NullString
		var accCreatedAt sql.NullTime
		var accUpdatedAt sql.NullTime

		err := rows.Scan(
			&notif.NotificationID, &notif.RecipientUserID, &notif.NotificationType, &entityID, &notif.IsRead, &createdAt,
			&triggeringUserID, // Scan the FK itself
			&accEmail, &accFirstName, &accLastName, &accAddress, &accPhone, &accAge, &accGender, &accCreatedAt, &accUpdatedAt,
		)
		if err != nil {
			log.Printf("GetMyNotifications DB Error scanning row: %v", err)
			continue // Skip this notification if scanning fails
		}

		// Assign core notification fields
		notif.CreatedAt = createdAt.Format(time.RFC3339)
		if entityID.Valid {
			notif.EntityID = &entityID.String
		} else {
			notif.EntityID = nil
		}

		// Populate triggering user if ID is valid (not NULL)
		if triggeringUserID.Valid {
			triggeringUser := &model.Account{
				AccountID: triggeringUserID.String, // Use the FK value
			}
			if accEmail.Valid {
				triggeringUser.Email = accEmail.String
			}
			if accFirstName.Valid {
				triggeringUser.FirstName = accFirstName.String
			}
			if accLastName.Valid {
				triggeringUser.LastName = accLastName.String
			}
			if accAddress.Valid {
				triggeringUser.Address = &accAddress.String
			}
			if accPhone.Valid {
				triggeringUser.Phone = &accPhone.String
			}
			if accAge.Valid {
				triggeringUser.Age = accAge.Int32
			}
			if accGender.Valid {
				triggeringUser.Gender = &accGender.String
			}
			if accCreatedAt.Valid {
				triggeringUser.CreatedAt = accCreatedAt.Time.Format(time.RFC3339)
			}
			if accUpdatedAt.Valid {
				updatedAtStr := accUpdatedAt.Time.Format(time.RFC3339)
				triggeringUser.UpdatedAt = &updatedAtStr
			}
			notif.TriggeringUser = triggeringUser
		} else {
			notif.TriggeringUser = nil // Explicitly set to nil if FK was NULL
		}

		notifications = append(notifications, &notif)
	}

	// 6. Check for errors during row iteration
	if err = rows.Err(); err != nil {
		log.Printf("GetMyNotifications DB Error iterating rows: %v", err)
		return nil, fmt.Errorf("error reading notifications list")
	}

	// 7. Return
	return notifications, nil
}
