package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"database/sql"
	"fmt"
	"graphql/graph/model"
	"log"
	"strings"
	"time"

	_ "github.com/lib/pq"
)

// CreatePost resolver - Belongs to mutationResolver
// Ensure the receiver (r *mutationResolver) is correct
func (r *mutationResolver) CreatePost(ctx context.Context, input model.CreatePostInput) (*model.Post, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("CreatePost DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	var postID string
	var createdAt time.Time
	insertCtx, cancelInsert := context.WithTimeout(ctx, 5*time.Second)
	defer cancelInsert()
	query := `INSERT INTO posts (title, content, author_id, created_at) VALUES ($1, $2, $3, NOW()) RETURNING post_id, created_at`
	err = db.QueryRowContext(insertCtx, query, input.Title, input.Content, input.AuthorID).Scan(&postID, &createdAt)
	if err != nil {
		log.Printf("Error creating post: %v", err)
		return nil, fmt.Errorf("failed to create post: %v", err)
	}

	log.Printf("Post created with ID: %s by author: %s", postID, input.AuthorID)

	// --- Create Notifications for Followers ---
	go func(authorID string, postID string, postCreatedAt time.Time) {
		log.Printf("Starting notification fan-out for post %s by author %s", postID, authorID)
		fanoutCtx, fanoutCancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer fanoutCancel()
		dbFanout, errDb := getDB()
		if errDb != nil {
			log.Printf("CreatePost Fanout DB Error: %v", errDb)
			return
		}
		defer dbFanout.Close()

		followersQuery := `SELECT follower_user_id FROM follows WHERE followed_user_id = $1`
		rows, errQuery := dbFanout.QueryContext(fanoutCtx, followersQuery, authorID)
		if errQuery != nil {
			log.Printf("CreatePost Fanout: Error querying followers for author %s: %v", authorID, errQuery)
			return
		}
		defer rows.Close()

		var followerIDs []string
		for rows.Next() {
			var followerID string
			if errScan := rows.Scan(&followerID); errScan != nil {
				log.Printf("CreatePost Fanout: Error scanning follower ID: %v", errScan)
				continue
			}
			followerIDs = append(followerIDs, followerID)
		}
		if errRows := rows.Err(); errRows != nil {
			log.Printf("CreatePost Fanout: Error iterating follower rows: %v", errRows)
		}
		if len(followerIDs) == 0 {
			log.Printf("CreatePost Fanout: No followers found for author %s.", authorID)
			return
		}

		log.Printf("CreatePost Fanout: Found %d followers for author %s. Inserting notifications...", len(followerIDs), authorID)
		notifQuery := `INSERT INTO notifications (recipient_user_id, triggering_user_id, notification_type, entity_id, is_read, created_at) VALUES ($1, $2, $3, $4, $5, $6)`
		stmt, errPrepare := dbFanout.PrepareContext(fanoutCtx, notifQuery)
		if errPrepare != nil {
			log.Printf("CreatePost Fanout: Error preparing notification statement: %v", errPrepare)
			return
		}
		defer stmt.Close()

		notificationType := "new_post"
		isRead := false
		triggeringUserID := authorID
		entityID := postID
		notificationTimestamp := postCreatedAt
		insertedCount := 0
		for _, recipientID := range followerIDs {
			if recipientID == authorID {
				continue
			}
			_, errInsert := stmt.ExecContext(fanoutCtx, recipientID, triggeringUserID, notificationType, entityID, isRead, notificationTimestamp)
			if errInsert != nil {
				log.Printf("CreatePost Fanout: Error inserting notification for recipient %s: %v", recipientID, errInsert)
			} else {
				insertedCount++
			}
		}
		log.Printf("CreatePost Fanout: Finished inserting notifications. %d successful inserts for post %s.", insertedCount, postID)
	}(input.AuthorID, postID, createdAt)

	// --- Publish to RabbitMQ (Optional) ---
	go func(pID string, title string, aID string) {
		// ... (existing rabbitmq logic, ensure it's correct if used) ...
	}(postID, input.Title, input.AuthorID)

	return &model.Post{PostID: postID, Title: input.Title, Content: input.Content, AuthorID: input.AuthorID, CreatedAt: createdAt.Format(time.RFC3339)}, nil
}

// UpdatePost is the resolver for the updatePost field.
func (r *mutationResolver) UpdatePost(ctx context.Context, input model.UpdatePostInput) (*model.Post, error) {
	// 1. Get the current authenticated user ID
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("UpdatePost Error: Authentication failed: %v", err)
		return nil, fmt.Errorf("authentication required")
	}
	log.Printf("UpdatePost: Authenticated as user: %s", currentUserID)

	// 2. Connect to the database
	db, err := getDB()
	if err != nil {
		log.Printf("UpdatePost DB Error: Failed to connect to database: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	// 3. First verify that the post exists and belongs to the current user
	var authorID string
	var createdAt time.Time
	verifyCtx, cancelVerify := context.WithTimeout(ctx, 5*time.Second)
	defer cancelVerify()

	verifyQuery := `SELECT author_id, created_at FROM posts WHERE post_id = $1`
	err = db.QueryRowContext(verifyCtx, verifyQuery, input.PostID).Scan(&authorID, &createdAt)
	if err != nil {
		if err == sql.ErrNoRows {
			log.Printf("UpdatePost: Post with ID %s not found", input.PostID)
			return nil, fmt.Errorf("post not found")
		}
		log.Printf("UpdatePost DB Error checking post ownership: %v", err)
		return nil, fmt.Errorf("failed to verify post ownership: %v", err)
	}
	log.Printf("UpdatePost: Post %s is owned by user %s", input.PostID, authorID)

	// 4. Check if the current user is the author of the post
	if authorID != currentUserID {
		log.Printf("UpdatePost: Unauthorized update attempt by user %s for post %s authored by %s", currentUserID, input.PostID, authorID)
		return nil, fmt.Errorf("unauthorized: you can only update your own posts")
	}

	// 5. Update the post
	updateCtx, cancelUpdate := context.WithTimeout(ctx, 5*time.Second)
	defer cancelUpdate()

	var updatedAt time.Time
	updateQuery := `UPDATE posts SET title = $1, content = $2, updated_at = NOW() WHERE post_id = $3 RETURNING updated_at`
	err = db.QueryRowContext(updateCtx, updateQuery, input.Title, input.Content, input.PostID).Scan(&updatedAt)
	if err != nil {
		log.Printf("UpdatePost DB Error updating post %s: %v", input.PostID, err)
		return nil, fmt.Errorf("failed to update post: %v", err)
	}

	// 6. Return the updated post
	// Format the timestamps as RFC3339 strings
	createdAtStr := createdAt.Format(time.RFC3339)
	updatedAtStr := updatedAt.Format(time.RFC3339)

	return &model.Post{
		PostID:    input.PostID,
		Title:     input.Title,
		Content:   input.Content,
		AuthorID:  authorID,
		CreatedAt: createdAtStr,
		UpdatedAt: &updatedAtStr,
	}, nil
}

// DeletePost resolver - Belongs to mutationResolver
func (r *mutationResolver) DeletePost(ctx context.Context, postID string) (bool, error) {
	// Add this detailed logging at the entry point
	log.Printf("DeletePost: Started with postID: %s", postID)

	// 1. Get the current authenticated user ID
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("DeletePost Error: Authentication failed: %v", err)
		return false, fmt.Errorf("authentication required")
	}
	log.Printf("DeletePost: Authenticated as user: %s", currentUserID)

	// 2. Connect to the database
	db, err := getDB()
	if err != nil {
		log.Printf("DeletePost DB Error: Failed to connect to database: %v", err)
		return false, fmt.Errorf("internal server error")
	}
	defer db.Close()

	// Test database connection
	if err := db.Ping(); err != nil {
		log.Printf("DeletePost DB Error: Failed to ping database: %v", err)
		return false, fmt.Errorf("internal server error")
	}
	log.Printf("DeletePost: Database connection successful")

	// 3. First verify that the post exists and belongs to the current user
	var authorID string
	verifyCtx, cancelVerify := context.WithTimeout(ctx, 5*time.Second)
	defer cancelVerify()

	log.Printf("DeletePost: Verifying post ownership for postID: %s", postID)
	verifyQuery := `SELECT author_id FROM posts WHERE post_id = $1`
	log.Printf("DeletePost: Running query: %s with param: %s", verifyQuery, postID)

	err = db.QueryRowContext(verifyCtx, verifyQuery, postID).Scan(&authorID)
	if err != nil {
		if err == sql.ErrNoRows {
			log.Printf("DeletePost: Post with ID %s not found", postID)
			return false, fmt.Errorf("post not found")
		}
		log.Printf("DeletePost DB Error checking post ownership: %v", err)
		return false, fmt.Errorf("failed to verify post ownership: %v", err)
	}
	log.Printf("DeletePost: Post %s is owned by user %s", postID, authorID)

	// 4. Check if the current user is the author of the post
	if authorID != currentUserID {
		log.Printf("DeletePost: Unauthorized deletion attempt by user %s for post %s authored by %s", currentUserID, postID, authorID)
		return false, fmt.Errorf("unauthorized: you can only delete your own posts")
	}

	// 5. Delete the post
	deleteCtx, cancelDelete := context.WithTimeout(ctx, 5*time.Second)
	defer cancelDelete()

	deleteQuery := `DELETE FROM posts WHERE post_id = $1`
	log.Printf("DeletePost: Running delete query: %s with param: %s", deleteQuery, postID)

	result, err := db.ExecContext(deleteCtx, deleteQuery, postID)
	if err != nil {
		log.Printf("DeletePost DB Error deleting post %s: %v", postID, err)
		return false, fmt.Errorf("failed to delete post: %v", err)
	}

	// 6. Check if the deletion was successful
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("DeletePost DB Error checking rows affected: %v", err)
		return false, fmt.Errorf("error checking deletion result: %v", err)
	}
	log.Printf("DeletePost: Deletion affected %d rows", rowsAffected)

	// 7. Delete notifications related to this post (optional cleanup)
	go func(postIDToCleanup string) {
		log.Printf("DeletePost: Starting async notification cleanup for post %s", postIDToCleanup)
		cleanupCtx, cancelCleanup := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancelCleanup()

		dbCleanup, errCleanup := getDB()
		if errCleanup != nil {
			log.Printf("DeletePost Notification Cleanup DB Error: %v", errCleanup)
			return
		}
		defer dbCleanup.Close()

		cleanupQuery := `DELETE FROM notifications WHERE entity_id = $1 AND notification_type = 'new_post'`
		log.Printf("DeletePost: Running notification cleanup query: %s with param: %s", cleanupQuery, postIDToCleanup)

		result, errDelete := dbCleanup.ExecContext(cleanupCtx, cleanupQuery, postIDToCleanup)
		if errDelete != nil {
			log.Printf("DeletePost Error cleaning up notifications for post %s: %v", postIDToCleanup, errDelete)
			return
		}

		rowsAffected, _ := result.RowsAffected()
		log.Printf("DeletePost: Successfully cleaned up %d notifications for post %s", rowsAffected, postIDToCleanup)
	}(postID)

	log.Printf("DeletePost: User %s successfully deleted post %s (Rows affected: %d)", currentUserID, postID, rowsAffected)
	return rowsAffected > 0, nil
}

// GetPost resolver - Belongs to queryResolver
func (r *queryResolver) GetPost(ctx context.Context, postID string) (*model.Post, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("GetPost DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()
	var post model.Post
	var author model.Account
	var createdAt time.Time
	var updatedAt sql.NullTime
	var authorFirstName, authorLastName sql.NullString
	var isFollowingAuthor sql.NullBool
	currentUserID, _ := getCurrentUserID(ctx)
	queryCtx, cancelQuery := context.WithTimeout(ctx, 5*time.Second)
	defer cancelQuery()
	query := `SELECT p.post_id, p.title, p.content, p.author_id, p.created_at, p.updated_at, a.first_name, a.last_name, EXISTS (SELECT 1 FROM follows WHERE follower_user_id = $1 AND followed_user_id = p.author_id) as is_following_author FROM posts p JOIN accounts a ON p.author_id = a.id WHERE p.post_id = $2`
	err = db.QueryRowContext(queryCtx, query, currentUserID, postID).Scan(&post.PostID, &post.Title, &post.Content, &post.AuthorID, &createdAt, &updatedAt, &authorFirstName, &authorLastName, &isFollowingAuthor)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil // Return nil for not found
		}
		log.Printf("Error fetching post %s: %v", postID, err)
		return nil, fmt.Errorf("failed to fetch post")
	}
	post.CreatedAt = createdAt.Format(time.RFC3339)
	if updatedAt.Valid {
		updatedStr := updatedAt.Time.Format(time.RFC3339)
		post.UpdatedAt = &updatedStr
	}
	author.AccountID = post.AuthorID
	if authorFirstName.Valid {
		author.FirstName = authorFirstName.String
	}
	if authorLastName.Valid {
		author.LastName = authorLastName.String
	}
	if isFollowingAuthor.Valid {
		author.IsFollowing = &isFollowingAuthor.Bool
	} else {
		defaultFollowStatus := false
		author.IsFollowing = &defaultFollowStatus
	}
	post.Author = &author
	return &post, nil
}

// ListPosts resolver - Belongs to queryResolver (fetches ALL posts)
func (r *queryResolver) ListPosts(ctx context.Context) ([]*model.Post, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("ListPosts DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()
	currentUserID, _ := getCurrentUserID(ctx)
	query := `SELECT p.post_id, p.title, p.content, p.author_id, p.created_at, p.updated_at, a.first_name, a.last_name, EXISTS (SELECT 1 FROM follows WHERE follower_user_id = $1 AND followed_user_id = p.author_id) as is_following_author FROM posts p LEFT JOIN accounts a ON p.author_id = a.id ORDER BY p.created_at DESC LIMIT 50`
	queryCtx, cancelQuery := context.WithTimeout(ctx, 10*time.Second)
	defer cancelQuery()
	rows, err := db.QueryContext(queryCtx, query, currentUserID)
	if err != nil {
		log.Printf("ListPosts DB Error querying: %v", err)
		return nil, fmt.Errorf("failed to list posts")
	}
	defer rows.Close()
	posts := []*model.Post{}
	for rows.Next() {
		var post model.Post
		var author model.Account
		var createdAt time.Time
		var updatedAt sql.NullTime
		var authorFirstName, authorLastName sql.NullString
		var isFollowingAuthor sql.NullBool
		err := rows.Scan(&post.PostID, &post.Title, &post.Content, &post.AuthorID, &createdAt, &updatedAt, &authorFirstName, &authorLastName, &isFollowingAuthor)
		if err != nil {
			log.Printf("ListPosts DB Error scanning row: %v", err)
			continue
		}
		post.CreatedAt = createdAt.Format(time.RFC3339)
		if updatedAt.Valid {
			formattedUpdatedAt := updatedAt.Time.Format(time.RFC3339)
			post.UpdatedAt = &formattedUpdatedAt
		}
		author.AccountID = post.AuthorID
		if authorFirstName.Valid {
			author.FirstName = authorFirstName.String
		}
		if authorLastName.Valid {
			author.LastName = authorLastName.String
		}
		if isFollowingAuthor.Valid {
			author.IsFollowing = &isFollowingAuthor.Bool
		} else {
			defaultFollowStatus := false
			author.IsFollowing = &defaultFollowStatus
		}
		post.Author = &author
		posts = append(posts, &post)
	}
	if err = rows.Err(); err != nil {
		log.Printf("ListPosts DB Error iterating rows: %v", err)
		return nil, fmt.Errorf("error reading posts list")
	}
	return posts, nil
}

// GetFeed resolver - Belongs to queryResolver
// Corrected signature with *int32
func (r *queryResolver) GetFeed(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("GetFeed Error: Not authenticated: %v", err)
		return []*model.Post{}, nil
	}

	db, err := getDB()
	if err != nil {
		log.Printf("GetFeed DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	// Use int32 for defaults and parameters
	actualLimit := int32(20)
	if limit != nil && *limit > 0 {
		actualLimit = *limit
	}
	actualOffset := int32(0)
	if offset != nil && *offset >= 0 {
		actualOffset = *offset
	}

	// --- Find who the current user follows ---
	followsCtx, followsCancel := context.WithTimeout(ctx, 5*time.Second)
	defer followsCancel()
	followsQuery := `SELECT followed_user_id FROM follows WHERE follower_user_id = $1`
	rowsFollows, errFollows := db.QueryContext(followsCtx, followsQuery, currentUserID)
	if errFollows != nil {
		log.Printf("GetFeed: Error querying follows: %v", errFollows)
		return nil, fmt.Errorf("failed to retrieve following list")
	}
	defer rowsFollows.Close()
	followedIDs := []string{}
	for rowsFollows.Next() {
		var followedID string
		if errScan := rowsFollows.Scan(&followedID); errScan != nil {
			log.Printf("GetFeed: Error scanning followed ID: %v", errScan)
			continue
		}
		followedIDs = append(followedIDs, followedID)
	}
	if errRows := rowsFollows.Err(); errRows != nil {
		log.Printf("GetFeed: Error iterating followed rows: %v", errRows)
	}
	if len(followedIDs) == 0 {
		log.Printf("GetFeed: User %s follows no one.", currentUserID)
		return []*model.Post{}, nil
	}

	// --- Build Query for Posts ---
	var postsQueryBuilder strings.Builder
	args := []interface{}{}
	argCounter := 1
	postsQueryBuilder.WriteString(`SELECT p.post_id, p.title, p.content, p.author_id, p.created_at, p.updated_at, a.first_name, a.last_name, EXISTS (SELECT 1 FROM follows WHERE follower_user_id = $`)
	postsQueryBuilder.WriteString(fmt.Sprintf("%d", argCounter))
	args = append(args, currentUserID)
	argCounter++
	postsQueryBuilder.WriteString(` AND followed_user_id = p.author_id) as is_following_author FROM posts p JOIN accounts a ON p.author_id = a.id WHERE p.author_id = ANY($`)
	postsQueryBuilder.WriteString(fmt.Sprintf("%d", argCounter))
	args = append(args, fmt.Sprintf("{%s}", strings.Join(followedIDs, ",")))
	argCounter++
	postsQueryBuilder.WriteString(") ORDER BY p.created_at DESC") // Added closing parenthesis for ANY
	postsQueryBuilder.WriteString(fmt.Sprintf(" LIMIT $%d", argCounter))
	args = append(args, actualLimit)
	argCounter++
	postsQueryBuilder.WriteString(fmt.Sprintf(" OFFSET $%d", argCounter))
	args = append(args, actualOffset)
	argCounter++
	finalPostsQuery := postsQueryBuilder.String()
	log.Printf("Executing GetFeed query for user %s: [%s] with args: %v", currentUserID, finalPostsQuery, args)

	// --- Execute and Scan ---
	postsCtx, postsCancel := context.WithTimeout(ctx, 15*time.Second)
	defer postsCancel()
	rowsPosts, errPosts := db.QueryContext(postsCtx, finalPostsQuery, args...)
	if errPosts != nil {
		log.Printf("GetFeed: DB Error querying posts: %v", errPosts)
		return nil, fmt.Errorf("failed to fetch feed posts")
	}
	defer rowsPosts.Close()
	posts := []*model.Post{}
	for rowsPosts.Next() {
		var post model.Post
		var author model.Account
		var createdAt time.Time
		var updatedAt sql.NullTime
		var authorFirstName, authorLastName sql.NullString
		var isFollowingAuthor bool
		errScan := rowsPosts.Scan(&post.PostID, &post.Title, &post.Content, &post.AuthorID, &createdAt, &updatedAt, &authorFirstName, &authorLastName, &isFollowingAuthor)
		if errScan != nil {
			log.Printf("GetFeed: Error scanning post row: %v", errScan)
			continue
		}
		post.CreatedAt = createdAt.Format(time.RFC3339)
		if updatedAt.Valid {
			formattedUpdatedAt := updatedAt.Time.Format(time.RFC3339)
			post.UpdatedAt = &formattedUpdatedAt
		}
		author.AccountID = post.AuthorID
		if authorFirstName.Valid {
			author.FirstName = authorFirstName.String
		}
		if authorLastName.Valid {
			author.LastName = authorLastName.String
		}
		author.IsFollowing = &isFollowingAuthor
		post.Author = &author
		posts = append(posts, &post)
	}
	if errRows := rowsPosts.Err(); errRows != nil {
		log.Printf("GetFeed: Error iterating posts rows: %v", errRows)
		return nil, fmt.Errorf("error reading feed posts list")
	}

	log.Printf("GetFeed: Returning %d posts for user %s", len(posts), currentUserID)
	return posts, nil
}
