package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"database/sql"
	"fmt"
	"graphql/graph/model"
	"log"
	"os"
	"time"

	_ "github.com/lib/pq"
	amqp091 "github.com/rabbitmq/amqp091-go"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.Account, error) {
	// Connect to the database
	connStr := os.Getenv("DATABASE_URL")
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		log.Fatalf("failed to connect to the database: %v", err)
		return nil, fmt.Errorf("internal error")
	}
	defer db.Close()

	// Insert the new account into the database
	var accountID string
	err = db.QueryRowContext(ctx, `
		INSERT INTO accounts (email, password, first_name, last_name, address, phone, age, gender, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
		RETURNING id
	`, input.Email, input.Password, input.FirstName, input.LastName, input.Address, input.Phone, input.Age, input.Gender).Scan(&accountID)
	if err != nil {
		log.Printf("failed to insert account: %v", err)
		return nil, fmt.Errorf("internal error")
	}

	// Publish a message to RabbitMQ
	rabbitmqURL := os.Getenv("RABBITMQ_URL") // Example: "amqp://guest:guest@localhost:5672/"
	conn, err := amqp091.Dial(rabbitmqURL)
	if err != nil {
		log.Printf("failed to connect to RabbitMQ: %v", err)
		// Optional: You can continue even if RabbitMQ fails
	} else {
		defer conn.Close()

		ch, err := conn.Channel()
		if err != nil {
			log.Printf("failed to open a channel: %v", err)
		} else {
			defer ch.Close()

			q, err := ch.QueueDeclare(
				"user_registered", // Queue name
				true,              // Durable
				false,             // Delete when unused
				false,             // Exclusive
				false,             // No-wait
				nil,               // Arguments
			)
			if err != nil {
				log.Printf("failed to declare a queue: %v", err)
			}

			body := fmt.Sprintf(`{"accountId":"%s","email":"%s"}`, accountID, input.Email)
			err = ch.PublishWithContext(ctx,
				"",     // Exchange
				q.Name, // Routing key
				false,  // Mandatory
				false,  // Immediate
				amqp091.Publishing{
					ContentType: "application/json",
					Body:        []byte(body),
					Timestamp:   time.Now(),
				},
			)
			if err != nil {
				log.Printf("failed to publish a message: %v", err)
			}
		}
	}

	// Return the created account
	return &model.Account{
		AccountID: accountID,
		Email:     input.Email,
		FirstName: input.FirstName,
		LastName:  input.LastName,
		Address:   input.Address,
		Phone:     input.Phone,
		Age:       input.Age,
		Gender:    input.Gender,
		CreatedAt: "now", // Replace with actual timestamp if needed
	}, nil
}

// GetAccount is the resolver for the getAccount field.
func (r *queryResolver) GetAccount(ctx context.Context, accountID string) (*model.Account, error) {
	panic(fmt.Errorf("not implemented: GetAccount - getAccount"))
}

// ListAccounts is the resolver for the listAccounts field.
func (r *queryResolver) ListAccounts(ctx context.Context) ([]*model.Account, error) {
	panic(fmt.Errorf("not implemented: ListAccounts - listAccounts"))
}
