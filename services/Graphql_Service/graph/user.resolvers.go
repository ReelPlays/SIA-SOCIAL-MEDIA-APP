package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"database/sql"
	"fmt"
	"graphql/graph/model"
	"log"
	"os"
	"time"

	_ "github.com/lib/pq"
	amqp091 "github.com/rabbitmq/amqp091-go"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.Account, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("Register DB Error: %v", err)
		return nil, fmt.Errorf("internal error connecting to DB")
	}
	defer db.Close()

	var accountID string
	var createdAt time.Time
	insertCtx, cancelInsert := context.WithTimeout(ctx, 5*time.Second)
	defer cancelInsert()
	err = db.QueryRowContext(insertCtx, `
		INSERT INTO accounts (email, password, first_name, last_name, address, phone, age, gender, created_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
		RETURNING id, created_at
	`, input.Email, input.Password, input.FirstName, input.LastName, input.Address, input.Phone, input.Age, input.Gender).Scan(&accountID, &createdAt)

	if err != nil {
		log.Printf("Register DB Error inserting account: %v", err)
		return nil, fmt.Errorf("internal error registering account")
	}

	// Publish a message to RabbitMQ
	go func() {
		rabbitmqURL := os.Getenv("RABBITMQ_URL")
		if rabbitmqURL == "" {
			log.Println("Register: RABBITMQ_URL not set, skipping message publish.")
			return
		}
		conn, err := amqp091.Dial(rabbitmqURL)
		if err != nil {
			log.Printf("Register: failed to connect to RabbitMQ: %v", err)
			return
		}
		defer conn.Close()
		ch, err := conn.Channel()
		if err != nil {
			log.Printf("Register: failed to open a channel: %v", err)
			return
		}
		defer ch.Close()
		q, err := ch.QueueDeclare("user_registered", true, false, false, false, nil)
		if err != nil {
			log.Printf("Register: failed to declare a queue: %v", err)
			return
		}
		body := fmt.Sprintf(`{"accountId":"%s","email":"%s"}`, accountID, input.Email)
		pubCtx, pubCancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer pubCancel()
		err = ch.PublishWithContext(pubCtx, "", q.Name, false, false, amqp091.Publishing{ContentType: "application/json", Body: []byte(body), Timestamp: time.Now()})
		if err != nil {
			log.Printf("Register: failed to publish user_registered message: %v", err)
		} else {
			log.Printf("Register: Published user_registered message for %s", accountID)
		}
	}()

	return &model.Account{AccountID: accountID, Email: input.Email, FirstName: input.FirstName, LastName: input.LastName, Address: input.Address, Phone: input.Phone, Age: input.Age, Gender: input.Gender, CreatedAt: createdAt.Format(time.RFC3339)}, nil
}

// FollowUser is the resolver for the followUser field.
func (r *mutationResolver) FollowUser(ctx context.Context, userIDToFollow string) (*model.Account, error) {
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("FollowUser Error: Not authenticated: %v", err)
		return nil, fmt.Errorf("authentication required")
	}
	if currentUserID == userIDToFollow {
		return nil, fmt.Errorf("cannot follow yourself")
	}

	db, err := getDB()
	if err != nil {
		log.Printf("FollowUser DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	var followedAccount model.Account
	var createdAt time.Time
	var updatedAt sql.NullTime
	queryCtx, cancelQuery := context.WithTimeout(ctx, 5*time.Second)
	err = db.QueryRowContext(queryCtx, `SELECT id, email, first_name, last_name, address, phone, age, gender, created_at, updated_at FROM accounts WHERE id = $1`, userIDToFollow).Scan(&followedAccount.AccountID, &followedAccount.Email, &followedAccount.FirstName, &followedAccount.LastName, &followedAccount.Address, &followedAccount.Phone, &followedAccount.Age, &followedAccount.Gender, &createdAt, &updatedAt)
	cancelQuery()
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user to follow not found")
		}
		log.Printf("FollowUser DB Error querying followed user %s: %v", userIDToFollow, err)
		return nil, fmt.Errorf("internal server error")
	}
	followedAccount.CreatedAt = createdAt.Format(time.RFC3339)
	if updatedAt.Valid {
		formattedUpdatedAt := updatedAt.Time.Format(time.RFC3339)
		followedAccount.UpdatedAt = &formattedUpdatedAt
	} else {
		followedAccount.UpdatedAt = nil
	}

	insertCtx, cancelInsert := context.WithTimeout(ctx, 5*time.Second)
	result, err := db.ExecContext(insertCtx, `INSERT INTO follows (follower_user_id, followed_user_id) VALUES ($1, $2) ON CONFLICT DO NOTHING`, currentUserID, userIDToFollow)
	cancelInsert()
	if err != nil {
		log.Printf("FollowUser DB Error inserting follow (%s -> %s): %v", currentUserID, userIDToFollow, err)
		return nil, fmt.Errorf("failed to follow user")
	}

	rowsAffected, _ := result.RowsAffected()
	log.Printf("User %s follow action for user %s (Rows affected: %d)", currentUserID, userIDToFollow, rowsAffected)

	if rowsAffected > 0 {
		log.Printf("New follow detected (%s -> %s), creating notification...", currentUserID, userIDToFollow)
		go func(recipientID string, triggerID string) {
			notifCtx, notifCancel := context.WithTimeout(context.Background(), 10*time.Second)
			defer notifCancel()
			dbNotif, errDb := getDB()
			if errDb != nil {
				log.Printf("FollowUser Notification Goroutine DB Error: %v", errDb)
				return
			}
			defer dbNotif.Close()
			_, errNotif := dbNotif.ExecContext(notifCtx, `INSERT INTO notifications (recipient_user_id, triggering_user_id, notification_type, entity_id, is_read, created_at) VALUES ($1, $2, $3, $4, $5, NOW())`, recipientID, triggerID, "new_follower", triggerID, false)
			if errNotif != nil {
				log.Printf("FollowUser: Failed to insert 'new_follower' notification for recipient %s: %v", recipientID, errNotif)
			} else {
				log.Printf("FollowUser: Inserted 'new_follower' notification for %s triggered by %s", recipientID, triggerID)
			}
		}(userIDToFollow, currentUserID)
	} else {
		log.Printf("User %s already follows %s or conflict occurred, no notification needed.", currentUserID, userIDToFollow)
	}

	return &followedAccount, nil
}

// UnfollowUser is the resolver for the unfollowUser field.
func (r *mutationResolver) UnfollowUser(ctx context.Context, userIDToUnfollow string) (*model.Account, error) {
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("UnfollowUser Error: Not authenticated: %v", err)
		return nil, fmt.Errorf("authentication required")
	}

	db, err := getDB()
	if err != nil {
		log.Printf("UnfollowUser DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	var unfollowedAccount model.Account
	var createdAt time.Time
	var updatedAt sql.NullTime
	queryCtx, cancelQuery := context.WithTimeout(ctx, 5*time.Second)
	err = db.QueryRowContext(queryCtx, `SELECT id, email, first_name, last_name, address, phone, age, gender, created_at, updated_at FROM accounts WHERE id = $1`, userIDToUnfollow).Scan(&unfollowedAccount.AccountID, &unfollowedAccount.Email, &unfollowedAccount.FirstName, &unfollowedAccount.LastName, &unfollowedAccount.Address, &unfollowedAccount.Phone, &unfollowedAccount.Age, &unfollowedAccount.Gender, &createdAt, &updatedAt)
	cancelQuery()
	if err != nil {
		log.Printf("UnfollowUser: Could not fetch unfollowed user %s, proceeding: %v", userIDToUnfollow, err)
		if err != sql.ErrNoRows {
			log.Printf("UnfollowUser DB Error querying user %s: %v", userIDToUnfollow, err)
		}
		unfollowedAccount.AccountID = userIDToUnfollow // Use ID for return even if fetch failed
	} else {
		unfollowedAccount.CreatedAt = createdAt.Format(time.RFC3339)
		if updatedAt.Valid {
			formattedUpdatedAt := updatedAt.Time.Format(time.RFC3339)
			unfollowedAccount.UpdatedAt = &formattedUpdatedAt
		} else {
			unfollowedAccount.UpdatedAt = nil
		}
	}

	deleteCtx, cancelDelete := context.WithTimeout(ctx, 5*time.Second)
	result, err := db.ExecContext(deleteCtx, `DELETE FROM follows WHERE follower_user_id = $1 AND followed_user_id = $2`, currentUserID, userIDToUnfollow)
	cancelDelete()
	if err != nil {
		log.Printf("UnfollowUser DB Error deleting follow (%s -> %s): %v", currentUserID, userIDToUnfollow, err)
		return nil, fmt.Errorf("failed to unfollow user")
	}

	rowsAffected, _ := result.RowsAffected()
	log.Printf("User %s unfollowed user %s (Rows affected: %d)", currentUserID, userIDToUnfollow, rowsAffected)

	return &unfollowedAccount, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, username *string, firstName *string, lastName *string, middleName *string, bio *string, profilePictureURL *string, bannerPictureURL *string, dateOfBirth *string, address *string, phone *string) (*model.Account, error) {
	// Get the current user ID
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("UpdateProfile Error: Not authenticated: %v", err)
		return nil, fmt.Errorf("authentication required")
	}

	db, err := getDB()
	if err != nil {
		log.Printf("UpdateProfile DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	// Build the SET part of the SQL query
	queryBuilder := "UPDATE accounts SET "
	args := []interface{}{}
	argIndex := 1
	needsComma := false

	// Only add fields that are being updated
	if username != nil {
		queryBuilder += fmt.Sprintf("username = $%d", argIndex)
		args = append(args, *username)
		argIndex++
		needsComma = true
	}

	if firstName != nil {
		if needsComma {
			queryBuilder += ", "
		}
		queryBuilder += fmt.Sprintf("first_name = $%d", argIndex)
		args = append(args, *firstName)
		argIndex++
		needsComma = true
	}

	if lastName != nil {
		if needsComma {
			queryBuilder += ", "
		}
		queryBuilder += fmt.Sprintf("last_name = $%d", argIndex)
		args = append(args, *lastName)
		argIndex++
		needsComma = true
	}

	if middleName != nil {
		if needsComma {
			queryBuilder += ", "
		}
		queryBuilder += fmt.Sprintf("middle_name = $%d", argIndex)
		args = append(args, *middleName)
		argIndex++
		needsComma = true
	}

	if bio != nil {
		if needsComma {
			queryBuilder += ", "
		}
		queryBuilder += fmt.Sprintf("bio = $%d", argIndex)
		args = append(args, *bio)
		argIndex++
		needsComma = true
	}

	if profilePictureURL != nil {
		if needsComma {
			queryBuilder += ", "
		}
		queryBuilder += fmt.Sprintf("profile_picture_url = $%d", argIndex)
		args = append(args, *profilePictureURL)
		argIndex++
		needsComma = true
	}

	if bannerPictureURL != nil {
		if needsComma {
			queryBuilder += ", "
		}
		queryBuilder += fmt.Sprintf("banner_picture_url = $%d", argIndex)
		args = append(args, *bannerPictureURL)
		argIndex++
		needsComma = true
	}

	if dateOfBirth != nil {
		if needsComma {
			queryBuilder += ", "
		}
		queryBuilder += fmt.Sprintf("date_of_birth = $%d", argIndex)
		args = append(args, *dateOfBirth)
		argIndex++
		needsComma = true
	}

	if address != nil {
		if needsComma {
			queryBuilder += ", "
		}
		queryBuilder += fmt.Sprintf("address = $%d", argIndex)
		args = append(args, *address)
		argIndex++
		needsComma = true
	}

	if phone != nil {
		if needsComma {
			queryBuilder += ", "
		}
		queryBuilder += fmt.Sprintf("phone = $%d", argIndex)
		args = append(args, *phone)
		argIndex++
		needsComma = true
	}

	// Always update the updated_at timestamp
	if needsComma {
		queryBuilder += ", "
	}
	queryBuilder += "updated_at = NOW()"
	needsComma = true

	// Add WHERE clause
	queryBuilder += fmt.Sprintf(" WHERE id = $%d RETURNING id, email, first_name, last_name, middle_name, username, bio, profile_picture_url, banner_picture_url, date_of_birth, address, phone, age, gender, created_at, updated_at", argIndex)
	args = append(args, currentUserID)

	// Execute the update
	updateCtx, cancelUpdate := context.WithTimeout(ctx, 5*time.Second)
	defer cancelUpdate()

	var account model.Account
	var email, firstName2, lastName2 string
	var middleName2, username2, bio2, profilePictureUrl2, bannerPictureUrl2 sql.NullString
	var dateOfBirth2, address2, phone2, gender2 sql.NullString
	var age int32
	var createdAt time.Time
	var updatedAt sql.NullTime

	err = db.QueryRowContext(updateCtx, queryBuilder, args...).Scan(
		&account.AccountID, &email, &firstName2, &lastName2, &middleName2, &username2, &bio2,
		&profilePictureUrl2, &bannerPictureUrl2, &dateOfBirth2, &address2, &phone2, &age, &gender2,
		&createdAt, &updatedAt,
	)

	if err != nil {
		log.Printf("UpdateProfile DB Error executing update: %v", err)
		return nil, fmt.Errorf("failed to update profile: %v", err)
	}

	// Set the account fields from the database results
	account.Email = email
	account.FirstName = firstName2
	account.LastName = lastName2
	account.Age = age
	account.CreatedAt = createdAt.Format(time.RFC3339)

	if updatedAt.Valid {
		updatedAtStr := updatedAt.Time.Format(time.RFC3339)
		account.UpdatedAt = &updatedAtStr
	}

	if middleName2.Valid {
		account.MiddleName = &middleName2.String
	}
	if username2.Valid {
		account.Username = &username2.String
	}
	if bio2.Valid {
		account.Bio = &bio2.String
	}
	if profilePictureUrl2.Valid {
		account.ProfilePictureURL = &profilePictureUrl2.String // Corrected field name
	}
	if bannerPictureUrl2.Valid {
		account.BannerPictureURL = &bannerPictureUrl2.String // Corrected field name
	}
	if dateOfBirth2.Valid {
		account.DateOfBirth = &dateOfBirth2.String
	}
	if address2.Valid {
		account.Address = &address2.String
	}
	if phone2.Valid {
		account.Phone = &phone2.String
	}
	if gender2.Valid {
		account.Gender = &gender2.String
	}

	return &account, nil
}

// GetAccount is the resolver for the getAccount field.
func (r *queryResolver) GetAccount(ctx context.Context, accountID string) (*model.Account, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("GetAccount DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	var account model.Account
	var createdAt time.Time
	var updatedAt sql.NullTime
	queryCtx, cancelQuery := context.WithTimeout(ctx, 5*time.Second)
	defer cancelQuery()
	err = db.QueryRowContext(queryCtx, `SELECT id, email, first_name, last_name, address, phone, age, gender, created_at, updated_at FROM accounts WHERE id = $1`, accountID).Scan(&account.AccountID, &account.Email, &account.FirstName, &account.LastName, &account.Address, &account.Phone, &account.Age, &account.Gender, &createdAt, &updatedAt)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("account not found")
		} // Return specific error
		log.Printf("GetAccount DB Error querying account %s: %v", accountID, err)
		return nil, fmt.Errorf("internal server error")
	}

	account.CreatedAt = createdAt.Format(time.RFC3339)
	if updatedAt.Valid {
		formattedUpdatedAt := updatedAt.Time.Format(time.RFC3339)
		account.UpdatedAt = &formattedUpdatedAt
	} else {
		account.UpdatedAt = nil
	}

	// Note: The Account.IsFollowing field is resolved by the accountResolver.IsFollowing method
	return &account, nil
}

// ListAccounts is the resolver for the listAccounts field.
func (r *queryResolver) ListAccounts(ctx context.Context) ([]*model.Account, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("ListAccounts DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	queryCtx, cancelQuery := context.WithTimeout(ctx, 10*time.Second)
	defer cancelQuery()
	rows, err := db.QueryContext(queryCtx, `SELECT id, email, first_name, last_name, address, phone, age, gender, created_at, updated_at FROM accounts ORDER BY created_at DESC`)

	if err != nil {
		log.Printf("ListAccounts DB Error querying: %v", err)
		return nil, fmt.Errorf("failed to list accounts")
	}
	defer rows.Close()

	accounts := []*model.Account{}
	for rows.Next() {
		var acc model.Account
		var createdAt time.Time
		var updatedAt sql.NullTime
		err := rows.Scan(&acc.AccountID, &acc.Email, &acc.FirstName, &acc.LastName, &acc.Address, &acc.Phone, &acc.Age, &acc.Gender, &createdAt, &updatedAt)
		if err != nil {
			log.Printf("ListAccounts DB Error scanning row: %v", err)
			continue
		}
		acc.CreatedAt = createdAt.Format(time.RFC3339)
		if updatedAt.Valid {
			formattedUpdatedAt := updatedAt.Time.Format(time.RFC3339)
			acc.UpdatedAt = &formattedUpdatedAt
		} else {
			acc.UpdatedAt = nil
		}
		// Note: The Account.IsFollowing field is resolved by the accountResolver.IsFollowing method for each account if requested in the query
		accounts = append(accounts, &acc)
	}
	if err = rows.Err(); err != nil {
		log.Printf("ListAccounts DB Error iterating rows: %v", err)
		return nil, fmt.Errorf("error reading accounts list")
	}

	return accounts, nil
}
