package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"graphql/graph/model"
	"net/http"
	"os"
)

// UpdatePassword is the resolver for updating password
func (r *mutationResolver) UpdatePassword(ctx context.Context, input model.UpdatePasswordInput) (*model.Profile, error) {
	profileServiceURL := os.Getenv("DATABASE_PROFILE_URL")
	if profileServiceURL == "" {
		profileServiceURL = "http://localhost:8081" // default URL
	}

	// Convert GraphQL input to Profile Service format
	passwordData := map[string]interface{}{
		"current_password": input.CurrentPassword,
		"new_password":     input.NewPassword,
	}

	jsonData, err := json.Marshal(passwordData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal password data: %v", err)
	}

	// Make request to Profile Service
	req, err := http.NewRequest(http.MethodPut, fmt.Sprintf("%s/profiles/%s/password", profileServiceURL, input.ProfileID), bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %v", err)
	}
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to update password: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to update password, status: %d", resp.StatusCode)
	}
	return r.Query().GetProfile(ctx, input.ProfileID)
}

// CreateProfile is the resolver for the createProfile field.
func (r *mutationResolver) CreateProfile(ctx context.Context, input model.CreateProfileInput) (*model.Profile, error) {
	profileServiceURL := os.Getenv("DATABASE_PROFILE_URL")
	if profileServiceURL == "" {
		profileServiceURL = "http://localhost:8081" // default URL
	}

	// Convert GraphQL input to Profile Service format
	profileData := map[string]interface{}{
		"username":            input.Username,
		"email":               input.Email,
		"password":            input.Password,
		"first_name":          input.FirstName,
		"middle_name":         input.MiddleName,
		"last_name":           input.LastName,
		"bio":                 input.Bio,
		"profile_picture_url": input.ProfilePictureURL,
		"banner_picture_url":  input.BannerPictureURL,
		"date_of_birth":       input.DateOfBirth,
		"address":             input.Address,
	}

	jsonData, err := json.Marshal(profileData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal profile data: %v", err)
	}

	// Make request to Profile Service
	resp, err := http.Post(profileServiceURL+"/profiles", "application/json", bytes.NewBuffer(jsonData)) // Changed from "services/Profile-Service"
	if err != nil {
		return nil, fmt.Errorf("failed to create profile: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		return nil, fmt.Errorf("failed to create profile, status: %d", resp.StatusCode)
	}

	var createdProfile struct {
		ProfileID         string  `json:"profile_id"`
		Username          string  `json:"username"`
		Email             string  `json:"email"`
		Password          string  `json:"password"`
		FirstName         *string `json:"first_name,omitempty"`
		MiddleName        *string `json:"middle_name,omitempty"`
		LastName          *string `json:"last_name,omitempty"`
		Bio               *string `json:"bio,omitempty"`
		ProfilePictureURL *string `json:"profile_picture_url,omitempty"`
		BannerPictureURL  *string `json:"banner_picture_url,omitempty"`
		DateOfBirth       *string `json:"date_of_birth,omitempty"`
		Address           *string `json:"address,omitempty"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&createdProfile); err != nil {
		return nil, fmt.Errorf("failed to decode response: %v", err)
	}

	// Convert to GraphQL model
	return &model.Profile{
		ProfileID:         createdProfile.ProfileID,
		Username:          createdProfile.Username,
		Email:             createdProfile.Email,
		Password:          createdProfile.Password,
		FirstName:         createdProfile.FirstName,
		MiddleName:        createdProfile.MiddleName,
		LastName:          createdProfile.LastName,
		Bio:               createdProfile.Bio,
		ProfilePictureURL: createdProfile.ProfilePictureURL,
		BannerPictureURL:  createdProfile.BannerPictureURL,
		DateOfBirth:       createdProfile.DateOfBirth,
		Address:           createdProfile.Address,
	}, nil
}

// GetProfile is the resolver for the getProfile field.
func (r *queryResolver) GetProfile(ctx context.Context, profileID string) (*model.Profile, error) {
	profileServiceURL := os.Getenv("DATABASE_PROFILE_URL")
	if profileServiceURL == "" {
		profileServiceURL = "http://localhost:8081" // default URL
	}

	// Make request to Profile Service
	resp, err := http.Get(fmt.Sprintf("%s/profiles/%s", profileServiceURL, profileID))
	if err != nil {
		return nil, fmt.Errorf("failed to get profile: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode == http.StatusNotFound {
		return nil, fmt.Errorf("profile not found")
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to get profile, status: %d", resp.StatusCode)
	}

	var profile struct {
		ProfileID         string `json:"profile_id"`
		Username          string `json:"username"`
		Email             string `json:"email"`
		FirstName         string `json:"first_name"`
		MiddleName        string `json:"middle_name"`
		LastName          string `json:"last_name"`
		Bio               string `json:"bio"`
		ProfilePictureURL string `json:"profile_picture_url"`
		BannerPictureURL  string `json:"banner_picture_url"`
		DateOfBirth       string `json:"date_of_birth"`
		Address           string `json:"address"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&profile); err != nil {
		return nil, fmt.Errorf("failed to decode response: %v", err)
	}

	// Convert to GraphQL model
	return &model.Profile{
		ProfileID:         profile.ProfileID,
		Username:          profile.Username,
		Email:             profile.Email,
		FirstName:         &profile.FirstName,
		MiddleName:        &profile.MiddleName,
		LastName:          &profile.LastName,
		Bio:               &profile.Bio,
		ProfilePictureURL: &profile.ProfilePictureURL,
		BannerPictureURL:  &profile.BannerPictureURL,
		DateOfBirth:       &profile.DateOfBirth,
		Address:           &profile.Address,
	}, nil
}

// ListProfiles is the resolver for the listProfiles field.
func (r *queryResolver) ListProfiles(ctx context.Context) ([]*model.Profile, error) {
	profileServiceURL := os.Getenv("DATABASE_PROFILE_URL")
	if profileServiceURL == "" {
		profileServiceURL = "http://localhost:8081" // default URL
	}

	// Make request to Profile Service
	resp, err := http.Get(profileServiceURL + "/profiles") // Changed from "services/Profile-Service"
	if err != nil {
		return nil, fmt.Errorf("failed to list profiles: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to list profiles, status: %d", resp.StatusCode)
	}

	var profiles []struct {
		ProfileID         string `json:"profile_id"`
		Username          string `json:"username"`
		Email             string `json:"email"`
		FirstName         string `json:"first_name"`
		MiddleName        string `json:"middle_name"`
		LastName          string `json:"last_name"`
		Bio               string `json:"bio"`
		ProfilePictureURL string `json:"profile_picture_url"`
		BannerPictureURL  string `json:"banner_picture_url"`
		DateOfBirth       string `json:"date_of_birth"`
		Address           string `json:"address"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&profiles); err != nil {
		return nil, fmt.Errorf("failed to decode response: %v", err)
	}

	// Convert to GraphQL models
	result := make([]*model.Profile, len(profiles))
	for i, p := range profiles {
		result[i] = &model.Profile{
			ProfileID:         p.ProfileID,
			Username:          p.Username,
			Email:             p.Email,
			FirstName:         &p.FirstName,
			MiddleName:        &p.MiddleName,
			LastName:          &p.LastName,
			Bio:               &p.Bio,
			ProfilePictureURL: &p.ProfilePictureURL,
			BannerPictureURL:  &p.BannerPictureURL,
			DateOfBirth:       &p.DateOfBirth,
			Address:           &p.Address,
		}
	}

	return result, nil
}
