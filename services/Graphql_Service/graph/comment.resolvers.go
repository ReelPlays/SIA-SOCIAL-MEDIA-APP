package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"database/sql"
	"fmt"
	"graphql/graph/model"
	"log"
	"time"
)

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.CreateCommentInput) (*model.Comment, error) {
	// Get authenticated user ID
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("CreateComment Error: Not authenticated: %v", err)
		return nil, fmt.Errorf("authentication required")
	}

	db, err := getDB()
	if err != nil {
		log.Printf("CreateComment DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	// First verify that the post exists
	var postExists bool
	verifyCtx, cancelVerify := context.WithTimeout(ctx, 5*time.Second)
	defer cancelVerify()
	err = db.QueryRowContext(verifyCtx, "SELECT EXISTS(SELECT 1 FROM posts WHERE post_id = $1)", input.PostID).Scan(&postExists)
	if err != nil {
		log.Printf("CreateComment DB Error verifying post: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	if !postExists {
		return nil, fmt.Errorf("post not found")
	}

	// Insert the comment
	var commentID string
	var createdAt time.Time
	insertCtx, cancelInsert := context.WithTimeout(ctx, 5*time.Second)
	defer cancelInsert()
	err = db.QueryRowContext(insertCtx,
		"INSERT INTO comments (post_id, author_id, content, created_at) VALUES ($1, $2, $3, NOW()) RETURNING comment_id, created_at",
		input.PostID, currentUserID, input.Content).Scan(&commentID, &createdAt)
	if err != nil {
		log.Printf("CreateComment DB Error inserting: %v", err)
		return nil, fmt.Errorf("failed to create comment")
	}

	// Generate notification for post author (if post author is not the current user)
	go func(postID string, authorID string, commentID string) {
		notifCtx, notifCancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer notifCancel()
		dbNotif, errDb := getDB()
		if errDb != nil {
			log.Printf("CreateComment Notification DB Error: %v", errDb)
			return
		}
		defer dbNotif.Close()

		// Get post author ID
		var postAuthorID string
		err := dbNotif.QueryRowContext(notifCtx, "SELECT author_id FROM posts WHERE post_id = $1", postID).Scan(&postAuthorID)
		if err != nil {
			log.Printf("CreateComment Notification Error getting post author: %v", err)
			return
		}

		// Only create notification if post author is not the commenter
		if postAuthorID != authorID {
			_, err = dbNotif.ExecContext(notifCtx,
				`INSERT INTO notifications (recipient_user_id, triggering_user_id, notification_type, entity_id, is_read, created_at) 
				VALUES ($1, $2, $3, $4, $5, NOW())`,
				postAuthorID, authorID, "new_comment", commentID, false)
			if err != nil {
				log.Printf("CreateComment Notification Error inserting: %v", err)
			} else {
				log.Printf("CreateComment: Created new_comment notification for user %s", postAuthorID)
			}
		}
	}(input.PostID, currentUserID, commentID)

	// Get author details
	var author model.Account
	author.AccountID = currentUserID
	queryAuthorCtx, cancelAuthorQuery := context.WithTimeout(ctx, 5*time.Second)
	defer cancelAuthorQuery()
	var accCreatedAt time.Time
	var accUpdatedAt sql.NullTime
	var authorFirstName, authorLastName, authorEmail sql.NullString
	err = db.QueryRowContext(queryAuthorCtx,
		"SELECT email, first_name, last_name, created_at, updated_at FROM accounts WHERE id = $1",
		currentUserID).Scan(&authorEmail, &authorFirstName, &authorLastName, &accCreatedAt, &accUpdatedAt)
	if err != nil {
		// Log error but continue with partial data
		log.Printf("CreateComment: Error fetching author details: %v", err)
		author.FirstName = "Unknown"
		author.LastName = "User"
		author.Email = "unknown@example.com"
	} else {
		if authorEmail.Valid {
			author.Email = authorEmail.String
		} else {
			author.Email = "unknown@example.com"
		}
		if authorFirstName.Valid {
			author.FirstName = authorFirstName.String
		} else {
			author.FirstName = "Unknown"
		}
		if authorLastName.Valid {
			author.LastName = authorLastName.String
		} else {
			author.LastName = "User"
		}
		author.CreatedAt = accCreatedAt.Format(time.RFC3339)
		if accUpdatedAt.Valid {
			updatedAtStr := accUpdatedAt.Time.Format(time.RFC3339)
			author.UpdatedAt = &updatedAtStr
		}
	}

	// Return the created comment with author information
	return &model.Comment{
		CommentID: commentID,
		PostID:    input.PostID,
		AuthorID:  currentUserID,
		Author:    &author,
		Content:   input.Content,
		CreatedAt: createdAt.Format(time.RFC3339),
	}, nil
}

// UpdateComment is the resolver for the updateComment field.
func (r *mutationResolver) UpdateComment(ctx context.Context, input model.UpdateCommentInput) (*model.Comment, error) {
	// Get authenticated user ID
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("UpdateComment Error: Not authenticated: %v", err)
		return nil, fmt.Errorf("authentication required")
	}

	db, err := getDB()
	if err != nil {
		log.Printf("UpdateComment DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	// First verify that the comment exists and belongs to the current user
	var postID string
	var authorID string
	verifyCtx, cancelVerify := context.WithTimeout(ctx, 5*time.Second)
	defer cancelVerify()
	err = db.QueryRowContext(verifyCtx,
		"SELECT post_id, author_id FROM comments WHERE comment_id = $1",
		input.CommentID).Scan(&postID, &authorID)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("comment not found")
		}
		log.Printf("UpdateComment DB Error checking comment: %v", err)
		return nil, fmt.Errorf("internal server error")
	}

	// Check if the current user is the author of the comment
	if authorID != currentUserID {
		return nil, fmt.Errorf("unauthorized: you can only update your own comments")
	}

	// Update the comment
	var updatedAt time.Time
	updateCtx, cancelUpdate := context.WithTimeout(ctx, 5*time.Second)
	defer cancelUpdate()
	err = db.QueryRowContext(updateCtx,
		"UPDATE comments SET content = $1, updated_at = NOW() WHERE comment_id = $2 RETURNING updated_at",
		input.Content, input.CommentID).Scan(&updatedAt)
	if err != nil {
		log.Printf("UpdateComment DB Error updating: %v", err)
		return nil, fmt.Errorf("failed to update comment")
	}

	// Get author details
	var author model.Account
	author.AccountID = currentUserID
	queryAuthorCtx, cancelAuthorQuery := context.WithTimeout(ctx, 5*time.Second)
	defer cancelAuthorQuery()
	var accCreatedAt time.Time
	var accUpdatedAt sql.NullTime
	var authorFirstName, authorLastName, authorEmail sql.NullString
	err = db.QueryRowContext(queryAuthorCtx,
		"SELECT email, first_name, last_name, created_at, updated_at FROM accounts WHERE id = $1",
		currentUserID).Scan(&authorEmail, &authorFirstName, &authorLastName, &accCreatedAt, &accUpdatedAt)
	if err != nil {
		// Log error but continue with partial data
		log.Printf("UpdateComment: Error fetching author details: %v", err)
		author.FirstName = "Unknown"
		author.LastName = "User"
		author.Email = "unknown@example.com"
	} else {
		if authorEmail.Valid {
			author.Email = authorEmail.String
		} else {
			author.Email = "unknown@example.com"
		}
		if authorFirstName.Valid {
			author.FirstName = authorFirstName.String
		} else {
			author.FirstName = "Unknown"
		}
		if authorLastName.Valid {
			author.LastName = authorLastName.String
		} else {
			author.LastName = "User"
		}
		author.CreatedAt = accCreatedAt.Format(time.RFC3339)
		if accUpdatedAt.Valid {
			updatedAtStr := accUpdatedAt.Time.Format(time.RFC3339)
			author.UpdatedAt = &updatedAtStr
		}
	}

	// Get createdAt from the original comment
	var createdAt time.Time
	err = db.QueryRowContext(ctx,
		"SELECT created_at FROM comments WHERE comment_id = $1",
		input.CommentID).Scan(&createdAt)
	if err != nil {
		// If there's an error, use the current time as fallback
		createdAt = time.Now()
	}

	updatedAtStr := updatedAt.Format(time.RFC3339)
	return &model.Comment{
		CommentID: input.CommentID,
		PostID:    postID,
		AuthorID:  currentUserID,
		Author:    &author,
		Content:   input.Content,
		CreatedAt: createdAt.Format(time.RFC3339),
		UpdatedAt: &updatedAtStr,
	}, nil
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, commentID string) (bool, error) {
	// Get authenticated user ID
	currentUserID, err := getCurrentUserID(ctx)
	if err != nil {
		log.Printf("DeleteComment Error: Not authenticated: %v", err)
		return false, fmt.Errorf("authentication required")
	}

	db, err := getDB()
	if err != nil {
		log.Printf("DeleteComment DB Error: %v", err)
		return false, fmt.Errorf("internal server error")
	}
	defer db.Close()

	// Verify the comment exists and is owned by the current user
	verifyCtx, cancelVerify := context.WithTimeout(ctx, 5*time.Second)
	defer cancelVerify()
	var authorID string
	err = db.QueryRowContext(verifyCtx,
		"SELECT author_id FROM comments WHERE comment_id = $1",
		commentID).Scan(&authorID)
	if err != nil {
		if err == sql.ErrNoRows {
			return false, fmt.Errorf("comment not found")
		}
		log.Printf("DeleteComment DB Error checking comment: %v", err)
		return false, fmt.Errorf("internal server error")
	}

	// Check if the current user is the author of the comment
	if authorID != currentUserID {
		return false, fmt.Errorf("unauthorized: you can only delete your own comments")
	}

	// Delete the comment
	deleteCtx, cancelDelete := context.WithTimeout(ctx, 5*time.Second)
	defer cancelDelete()
	result, err := db.ExecContext(deleteCtx,
		"DELETE FROM comments WHERE comment_id = $1",
		commentID)
	if err != nil {
		log.Printf("DeleteComment DB Error deleting: %v", err)
		return false, fmt.Errorf("failed to delete comment")
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("DeleteComment Error checking rows affected: %v", err)
		return false, nil
	}

	// Clean up notifications related to this comment
	go func(commentID string) {
		cleanupCtx, cancelCleanup := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancelCleanup()
		dbCleanup, errCleanup := getDB()
		if errCleanup != nil {
			log.Printf("DeleteComment Notification Cleanup DB Error: %v", errCleanup)
			return
		}
		defer dbCleanup.Close()

		_, err := dbCleanup.ExecContext(cleanupCtx,
			"DELETE FROM notifications WHERE entity_id = $1 AND notification_type = 'new_comment'",
			commentID)
		if err != nil {
			log.Printf("DeleteComment Error cleaning up notifications: %v", err)
		}
	}(commentID)

	return rowsAffected > 0, nil
}

// GetComment is the resolver for the getComment field.
func (r *queryResolver) GetComment(ctx context.Context, commentID string) (*model.Comment, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("GetComment DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	var comment model.Comment
	var authorFirstName, authorLastName, authorEmail sql.NullString
	var createdAt time.Time
	var updatedAt sql.NullTime
	queryCtx, cancelQuery := context.WithTimeout(ctx, 5*time.Second)
	defer cancelQuery()
	err = db.QueryRowContext(queryCtx, `
		SELECT c.comment_id, c.post_id, c.author_id, c.content, c.created_at, c.updated_at,
		       a.first_name, a.last_name, a.email
		FROM comments c
		LEFT JOIN accounts a ON c.author_id = a.id
		WHERE c.comment_id = $1`,
		commentID).Scan(
		&comment.CommentID, &comment.PostID, &comment.AuthorID, &comment.Content,
		&createdAt, &updatedAt, &authorFirstName, &authorLastName, &authorEmail)

	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil // Return nil for not found
		}
		log.Printf("GetComment DB Error scanning: %v", err)
		return nil, fmt.Errorf("internal server error")
	}

	comment.CreatedAt = createdAt.Format(time.RFC3339)
	if updatedAt.Valid {
		updatedAtStr := updatedAt.Time.Format(time.RFC3339)
		comment.UpdatedAt = &updatedAtStr
	}

	// Initialize author
	author := &model.Account{
		AccountID: comment.AuthorID,
	}
	if authorEmail.Valid {
		author.Email = authorEmail.String
	} else {
		author.Email = "unknown@example.com"
	}
	if authorFirstName.Valid {
		author.FirstName = authorFirstName.String
	} else {
		author.FirstName = "Unknown"
	}
	if authorLastName.Valid {
		author.LastName = authorLastName.String
	} else {
		author.LastName = "User"
	}
	comment.Author = author

	return &comment, nil
}

// GetPostComments is the resolver for the getPostComments field.
func (r *queryResolver) GetPostComments(ctx context.Context, postID string, limit *int32, offset *int32) ([]*model.Comment, error) {
	db, err := getDB()
	if err != nil {
		log.Printf("GetPostComments DB Error: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer db.Close()

	// Set default values if nil
	limitVal := int32(20)
	if limit != nil {
		limitVal = *limit
	}
	offsetVal := int32(0)
	if offset != nil {
		offsetVal = *offset
	}

	queryCtx, cancelQuery := context.WithTimeout(ctx, 10*time.Second)
	defer cancelQuery()
	rows, err := db.QueryContext(queryCtx, `
		SELECT c.comment_id, c.post_id, c.author_id, c.content, c.created_at, c.updated_at,
		       a.first_name, a.last_name, a.email, a.created_at as author_created_at, a.updated_at as author_updated_at
		FROM comments c
		LEFT JOIN accounts a ON c.author_id = a.id
		WHERE c.post_id = $1
		ORDER BY c.created_at ASC
		LIMIT $2 OFFSET $3`,
		postID, limitVal, offsetVal)

	if err != nil {
		log.Printf("GetPostComments DB Error querying: %v", err)
		return nil, fmt.Errorf("internal server error")
	}
	defer rows.Close()

	comments := []*model.Comment{}
	for rows.Next() {
		var comment model.Comment
		var authorFirstName, authorLastName, authorEmail sql.NullString
		var createdAt, authorCreatedAt time.Time
		var updatedAt, authorUpdatedAt sql.NullTime
		err := rows.Scan(
			&comment.CommentID, &comment.PostID, &comment.AuthorID, &comment.Content,
			&createdAt, &updatedAt, &authorFirstName, &authorLastName, &authorEmail,
			&authorCreatedAt, &authorUpdatedAt)

		if err != nil {
			log.Printf("GetPostComments DB Error scanning row: %v", err)
			continue
		}

		comment.CreatedAt = createdAt.Format(time.RFC3339)
		if updatedAt.Valid {
			updatedAtStr := updatedAt.Time.Format(time.RFC3339)
			comment.UpdatedAt = &updatedAtStr
		}

		// Set author details
		author := &model.Account{
			AccountID: comment.AuthorID,
			CreatedAt: authorCreatedAt.Format(time.RFC3339),
		}
		if authorEmail.Valid {
			author.Email = authorEmail.String
		} else {
			author.Email = "unknown@example.com"
		}
		if authorUpdatedAt.Valid {
			authorUpdatedAtStr := authorUpdatedAt.Time.Format(time.RFC3339)
			author.UpdatedAt = &authorUpdatedAtStr
		}
		if authorFirstName.Valid {
			author.FirstName = authorFirstName.String
		} else {
			author.FirstName = "Unknown"
		}
		if authorLastName.Valid {
			author.LastName = authorLastName.String
		} else {
			author.LastName = "User"
		}

		comment.Author = author
		comments = append(comments, &comment)
	}

	if err = rows.Err(); err != nil {
		log.Printf("GetPostComments DB Error iterating rows: %v", err)
		return nil, fmt.Errorf("internal server error")
	}

	return comments, nil
}
